
Projeto: CreditOrchestrator

Objetivo:
Construir um sistema distribuído para validação de crédito, aplicando múltiplas regras bancárias de forma assíncrona, segura, observável e persistente, utilizando:
- C# .NET moderno
- AWS (SQS, Terraform)
- PostgreSQL distribuído
- Observabilidade com OpenTelemetry

Arquitetura Geral:
- API REST: recebe pedidos de crédito e envia para o SQS
- Worker: consome mensagens do SQS, aplica regras e persiste no banco
- Core: regras de negócio, entidades e resultados (DDD)
- Banco PostgreSQL: persistência de requisições e decisões
- Observabilidade: Prometheus + Grafana via OpenTelemetry
- Infraestrutura como código: Terraform para filas, roles, banco

Camadas:

1. CreditOrchestrator.Core/
- Entities/CreditRequest.cs
- Interfaces/ICreditRule.cs
- Enums/CreditDecision.cs
- Results/RuleValidationResult.cs, CreditValidationResult.cs
- Rules/AgeValidationRule.cs, ScoreValidationRule.cs, CpfBlacklistRule.cs, IncomeToLoanRatioRule.cs, PaymentHistoryRule.cs

2. CreditOrchestrator.API/
- Controllers/CreditRequestController.cs
- Models/CreditRequestDto.cs, CreditResultDto.cs
- Utils/CreditRequestMapper.cs

3. CreditOrchestrator.Workers/
- HostedService que consome SQS
- Executa regras com CreditRequestValidator
- Persiste resultado no PostgreSQL
- Registra observabilidade

4. CreditOrchestrator.Infrastructure/
- Integração com SQS
- Banco PostgreSQL (EF Core ou Dapper)
- OpenTelemetry

5. Banco PostgreSQL distribuído:
- Tabela: CreditRequests
  request_id UUID PRIMARY KEY
  full_name TEXT
  cpf TEXT
  credit_score INT
  monthly_income DECIMAL
  requested_amount DECIMAL
  is_approved BOOLEAN
  decision TEXT
  created_at TIMESTAMP

6. Tests/
- Unitários (xUnit + Moq)
- Integração com CreditRequestValidator
- Mapeamento DTO → Entidade

Extras:
- Retry com backoff
- DLQ
- Dashboard Grafana
- CI/CD com SonarQube

Resultado esperado:
Sistema modular, rastreável e observável, com mensageria, domínio limpo e persistência distribuída.